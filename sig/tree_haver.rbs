# Type definitions for TreeHaver
#
# TreeHaver is a cross-Ruby adapter for code parsing with 10 backends:
# - Tree-sitter: MRI, Rust, FFI, Java
# - Native parsers: Prism (Ruby), Psych (YAML), Commonmarker (Markdown), Markly (GFM)
# - Pure Ruby: Citrus

module TreeHaver
  VERSION: String

  # Base error class
  class Error < StandardError
  end

  # Raised when a backend or feature is not available
  class NotAvailable < Error
  end

  # Module namespace for backend implementations
  module Backends
  end

  # Get the current backend selection
  def self.backend: () -> Symbol

  # Set the backend to use
  def self.backend=: (Symbol | String | nil name) -> (Symbol | nil)

  # Reset backend selection memoization
  def self.reset_backend!: (?to: Symbol | String | nil) -> void

  # Determine the concrete backend module to use
  def self.backend_module: () -> Module?

  # Get capabilities of the current backend
  def self.capabilities: () -> Hash[Symbol, untyped]

  # Register a language helper by name
  def self.register_language: (Symbol | String name, path: String, ?symbol: String?) -> void

  # Unregister a previously registered language helper
  def self.unregister_language: (Symbol | String name) -> void

  # Clear all registered languages
  def self.clear_languages!: () -> void

  # Fetch a registered language entry
  def self.registered_language: (Symbol | String name) -> Hash[Symbol, String?]?

  # Represents a tree-sitter language grammar
  class Language
    # Load a language grammar from a shared library
    def self.from_library: (String path, ?symbol: String?, ?name: String?) -> Language

    # Alias for from_library
    def self.from_path: (String path, ?symbol: String?, ?name: String?) -> Language

    def self.method_missing: (Symbol method_name, *untyped args, **untyped kwargs) ?{ () -> untyped } -> Language

    def self.respond_to_missing?: (Symbol method_name, ?bool include_private) -> bool
  end

  # Represents a tree-sitter parser instance
  class Parser
    # Create a new parser instance
    def initialize: () -> void

    # Set the language grammar for this parser
    def language=: (Language lang) -> Language

    # Parse source code into a syntax tree
    def parse: (String source) -> Tree

    # Parse with optional incremental parsing support
    def parse_string: (Tree? old_tree, String source) -> Tree

    private

    @impl: untyped
  end

  # Represents a parsed syntax tree
  class Tree
    attr_reader inner_tree: untyped
    attr_reader source: String?

    # Get the root node of the syntax tree
    def root_node: () -> Node?

    # Edit the tree for incremental parsing
    def edit: (
      start_byte: Integer,
      old_end_byte: Integer,
      new_end_byte: Integer,
      start_point: Hash[Symbol, Integer],
      old_end_point: Hash[Symbol, Integer],
      new_end_point: Hash[Symbol, Integer]
    ) -> void

    # Check if the current backend supports incremental parsing
    def supports_editing?: () -> bool

    # String representation
    def inspect: () -> String

    # Check if tree responds to a method (includes delegation to inner_tree)
    def respond_to_missing?: (Symbol method_name, ?bool include_private) -> bool

    # Delegate unknown methods to the underlying backend-specific tree
    def method_missing: (Symbol method_name, *untyped args, **untyped kwargs) ?{ () -> untyped } -> untyped

    private

    def initialize: (untyped inner_tree, ?source: String?) -> void
  end

  # Represents a node in the syntax tree
  class Node
    attr_reader inner_node: untyped
    attr_reader source: String?

    # Get the type name of this node
    def type: () -> String

    # Get the text content of this node
    def text: () -> String?

    # Get the start byte offset
    def start_byte: () -> Integer

    # Get the end byte offset
    def end_byte: () -> Integer

    # Get the start point (row, column)
    def start_point: () -> Point

    # Get the end point (row, column)
    def end_point: () -> Point

    # Position API - consistent across all backends
    # Get 1-based line number where node starts
    def start_line: () -> Integer

    # Get 1-based line number where node ends
    def end_line: () -> Integer

    # Get complete position information as hash
    # Returns {start_line:, end_line:, start_column:, end_column:}
    def source_position: () -> Hash[Symbol, Integer]

    # Get first child node (convenience method)
    def first_child: () -> Node?

    # Get the number of child nodes
    def child_count: () -> Integer

    # Get a child node by index
    def child: (Integer index) -> Node?

    # Get all children as an array
    def children: () -> Array[Node]

    # Iterate over child nodes
    def each: () { (Node child) -> void } -> nil
            | () -> Enumerator[Node, nil]

    # Get a named child by field name
    def child_by_field_name: (String | Symbol field_name) -> Node?

    # Get the parent node
    def parent: () -> Node?

    # Get the next sibling node
    def next_sibling: () -> Node?

    # Get the previous sibling node
    def prev_sibling: () -> Node?

    # Check if node responds to a method (includes delegation to inner_node)
    def respond_to_missing?: (Symbol method_name, ?bool include_private) -> bool

    # Delegate unknown methods to the underlying backend-specific node
    def method_missing: (Symbol method_name, *untyped args, **untyped kwargs) ?{ () -> untyped } -> untyped

    private

    def initialize: (untyped inner_node, ?source: String?) -> void
  end

  # Position in source code that works as both object and hash
  class Point
    attr_reader row: Integer
    attr_reader column: Integer

    def initialize: (row: Integer, column: Integer) -> void

    # Hash-style access
    def []: (Symbol key) -> Integer?

    # Convert to hash
    def to_h: () -> Hash[Symbol, Integer]

    # String representation
    def inspect: () -> String
  end

  # Thread-safe language registrations and cache
  module LanguageRegistry
    # Register a language helper by name
    def self.register: (Symbol | String name, path: String, ?symbol: String?) -> void

    # Unregister a previously registered language helper
    def self.unregister: (Symbol | String name) -> void

    # Fetch a registration entry
    def self.registered: (Symbol | String name) -> Hash[Symbol, String?]?

    # Clear all registrations
    def self.clear_registrations!: () -> void

    # Fetch a cached language by key or compute and store it
    def self.fetch: [T] (Array[untyped] key) { () -> T } -> T

    # Clear the language cache
    def self.clear_cache!: () -> void

    # Clear everything (registrations and cache)
    def self.clear_all!: () -> void
  end

  module Version
    VERSION: String
  end
end
