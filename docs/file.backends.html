<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  File: backends
  
    &mdash; Documentation by YARD 0.9.38
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" />

  <link rel="stylesheet" href="css/common.css" type="text/css" />

<script type="text/javascript">
  pathId = "backends";
  relpath = '';
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="file_list.html?1"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  
    <a href="_index.html">Index</a> &raquo; 
    <span class="title">File: backends</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <div id="content"><div id='filecontents'><h1 id="type-definitions-for-treehaver-backends">Type definitions for TreeHaver backends</h1>

<p>module TreeHaver<br>
  module Backends<br>
    # MRI backend using ruby_tree_sitter<br>
    module MRI<br>
      # Check if the MRI backend is available<br>
      def self.available?: () -&gt; bool</p>

<pre class="code ruby"><code class="ruby">  # Get capabilities supported by this backend
  def self.capabilities: () -&gt; Hash[Symbol, untyped]

  class Language
    # Load a language from a shared library path
    def self.from_path: (String path) -&gt; untyped
  end

  class Parser
    # Create a new parser instance
    def initialize: () -&gt; void

    # Set the language for this parser
    def language=: (untyped lang) -&gt; untyped

    # Parse source code
    def parse: (String source) -&gt; untyped

    # Parse source code with optional incremental parsing
    def parse_string: (untyped? old_tree, String source) -&gt; untyped

    private

    @parser: untyped
  end

  class Tree
  end

  class Node
  end
end

# FFI-based backend for calling libtree-sitter directly
module FFI
  # Native FFI bindings to libtree-sitter
  module Native
    # Get list of candidate library names
    def self.lib_candidates: () -&gt; Array[String]

    # Load the tree-sitter runtime library
    def self.try_load!: () -&gt; void

    # Check if the library is loaded
    def self.loaded?: () -&gt; bool

    # FFI struct representation of TSNode
    class TSNode &lt; ::FFI::Struct
    end

    def self.ts_parser_new: () -&gt; ::FFI::Pointer

    def self.ts_parser_delete: (::FFI::Pointer ptr) -&gt; void

    def self.ts_parser_set_language: (::FFI::Pointer parser, ::FFI::Pointer language) -&gt; bool

    def self.ts_parser_parse_string: (::FFI::Pointer parser, ::FFI::Pointer old_tree, String source, Integer length) -&gt; ::FFI::Pointer

    def self.ts_tree_delete: (::FFI::Pointer ptr) -&gt; void

    def self.ts_tree_root_node: (::FFI::Pointer tree) -&gt; TSNode

    def self.ts_node_type: (TSNode node) -&gt; String

    def self.ts_node_child_count: (TSNode node) -&gt; Integer

    def self.ts_node_child: (TSNode node, Integer index) -&gt; TSNode
  end

  # Check if the FFI backend is available
  def self.available?: () -&gt; bool

  # Get capabilities supported by this backend
  def self.capabilities: () -&gt; Hash[Symbol, untyped]

  class Language
    # The FFI pointer to the TSLanguage struct
    attr_reader pointer: ::FFI::Pointer

    # Load a language from a shared library
    def self.from_library: (String path, ?symbol: String?, ?name: String?) -&gt; Language

    # Alias for from_library
    def self.from_path: (String path, ?symbol: String?, ?name: String?) -&gt; Language

    # Convert to FFI pointer
    def to_ptr: () -&gt; ::FFI::Pointer

    private

    def initialize: (::FFI::Pointer ptr) -&gt; void
  end

  class Parser
    # Create a new parser instance
    def initialize: () -&gt; void

    # Get finalizer for cleanup
    def self.finalizer: (::FFI::Pointer ptr) -&gt; Proc

    # Set the language for this parser
    def language=: (Language lang) -&gt; Language

    # Parse source code into a syntax tree
    def parse: (String source) -&gt; Tree

    private

    @parser: ::FFI::Pointer
  end

  class Tree
    # Get finalizer for cleanup
    def self.finalizer: (::FFI::Pointer ptr) -&gt; Proc

    # Get the root node of the syntax tree
    def root_node: () -&gt; Node

    private

    def initialize: (::FFI::Pointer ptr) -&gt; void

    @ptr: ::FFI::Pointer
  end

  class Node
    # Get the type name of this node
    def type: () -&gt; String

    # Iterate over child nodes
    def each: () { (Node child) -&gt; void } -&gt; nil
            | () -&gt; Enumerator[Node, nil]

    private

    def initialize: (Native::TSNode ts_node_value) -&gt; void

    @val: Native::TSNode
  end
end

# Java backend for JRuby using java-tree-sitter
module Java
  JAVA_PACKAGE: String

  # Attempt to append JARs from ENV to JRuby classpath
  def self.add_jars_from_env!: () -&gt; void

  # Check if the Java backend is available
  def self.available?: () -&gt; bool

  # Reset the load state (for testing)
  def self.reset!: () -&gt; void

  # Get the loaded Java classes
  def self.java_classes: () -&gt; Hash[Symbol, untyped]

  # Get capabilities supported by this backend
  def self.capabilities: () -&gt; Hash[Symbol, untyped]

  class Language
    attr_reader impl: untyped

    def initialize: (untyped impl) -&gt; void

    def self.from_library: (String path, ?symbol: String?, ?name: String?) -&gt; Language

    def self.from_path: (String path, ?symbol: String?, ?name: String?) -&gt; Language
  end

  class Parser
    def initialize: () -&gt; void

    def language=: (Language | untyped lang) -&gt; void

    def parse: (String source) -&gt; Tree

    def parse_string: (Tree? old_tree, String source) -&gt; Tree

    private

    @parser: untyped
  end

  class Tree
    attr_reader impl: untyped

    def initialize: (untyped impl) -&gt; void

    def root_node: () -&gt; Node

    def edit: (
      start_byte: Integer,
      old_end_byte: Integer,
      new_end_byte: Integer,
      start_point: Hash[Symbol, Integer],
      old_end_point: Hash[Symbol, Integer],
      new_end_point: Hash[Symbol, Integer]
    ) -&gt; void
  end

  class Node
    attr_reader impl: untyped

    def initialize: (untyped impl) -&gt; void

    def type: () -&gt; String

    def child_count: () -&gt; Integer

    def child: (Integer index) -&gt; Node

    def each: () { (Node) -&gt; void } -&gt; void
            | () -&gt; Enumerator[Node, nil]

    def start_byte: () -&gt; Integer

    def end_byte: () -&gt; Integer

    def start_point: () -&gt; Hash[Symbol, Integer]

    def end_point: () -&gt; Hash[Symbol, Integer]

    def has_error?: () -&gt; bool

    def missing?: () -&gt; bool

    def text: () -&gt; String
  end
end

# Rust backend using tree_stump
module Rust
  # Check if the Rust backend is available
  def self.available?: () -&gt; bool

  # Reset the load state (for testing)
  def self.reset!: () -&gt; void

  # Get capabilities supported by this backend
  def self.capabilities: () -&gt; Hash[Symbol, untyped]

  class Language
    # Load a language from a shared library path
    def self.from_library: (String path, ?symbol: String?, ?name: String?) -&gt; untyped

    # Alias for from_library
    def self.from_path: (String path) -&gt; untyped
  end

  class Parser
    # Create a new parser instance
    def initialize: () -&gt; void

    # Set the language for this parser
    def language=: (untyped lang) -&gt; untyped

    # Parse source code
    def parse: (String source) -&gt; untyped

    # Parse source code with optional incremental parsing
    def parse_string: (untyped? old_tree, String source) -&gt; untyped

    private

    @parser: untyped
  end

  class Tree
  end

  class Node
  end
end

# Citrus backend using pure Ruby Citrus parser
module Citrus
  # Check if the Citrus backend is available
  def self.available?: () -&gt; bool

  # Reset the load state (for testing)
  def self.reset!: () -&gt; void

  # Get capabilities supported by this backend
  def self.capabilities: () -&gt; Hash[Symbol, untyped]

  class Language
    attr_reader grammar_module: untyped

    # Create a new language from a Citrus grammar module
    def initialize: (untyped grammar_module) -&gt; void
  end

  class Parser
    # Create a new parser instance
    def initialize: () -&gt; void

    # Set the grammar for this parser
    def language=: (Language | untyped grammar) -&gt; (Language | untyped)

    # Parse source code
    def parse: (String source) -&gt; untyped

    private

    @grammar: untyped
  end

  class Tree
    attr_reader root_match: untyped
    attr_reader source: String

    def initialize: (untyped root_match, String source) -&gt; void

    def root_node: () -&gt; Node
  end

  class Node
    attr_reader match: untyped
    attr_reader source: String

    def initialize: (untyped match, String source) -&gt; void

    def type: () -&gt; String

    def start_byte: () -&gt; Integer

    def end_byte: () -&gt; Integer

    def text: () -&gt; String

    def child_count: () -&gt; Integer

    def child: (Integer index) -&gt; Node?

    def children: () -&gt; Array[Node]

    def each: () { (Node) -&gt; void } -&gt; void
            | () -&gt; Enumerator[Node, nil]
  end
end   end end
</code></pre>
</div></div>

      <div id="footer">
  Generated on Mon Dec 29 15:21:11 2025 by
  <a href="https://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.9.38 (ruby-4.0.0).
</div>

    </div>
  </body>
</html>