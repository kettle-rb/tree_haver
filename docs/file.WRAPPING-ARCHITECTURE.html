<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  File: WRAPPING-ARCHITECTURE
  
    &mdash; Documentation by YARD 0.9.38
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" />

  <link rel="stylesheet" href="css/common.css" type="text/css" />

<script type="text/javascript">
  pathId = "WRAPPING-ARCHITECTURE";
  relpath = '';
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="file_list.html?1"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  
    <a href="_index.html">Index</a> &raquo; 
    <span class="title">File: WRAPPING-ARCHITECTURE</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <div id="content"><div id='filecontents'><h1 id="treehaver-wrappingunwrapping-architecture">TreeHaver Wrapping/Unwrapping Architecture</h1>

<h2 id="principle-of-least-surprise-pols">Principle of Least Surprise (PoLS)</h2>

<p>TreeHaver follows a <strong>single responsibility</strong> pattern for object wrapping:</p>

<p><strong>TreeHaver::Parser (top level) handles ALL wrapping and unwrapping.</strong><br>
<strong>Backends work exclusively with raw backend objects.</strong><br>
<strong>User-facing API uses only TreeHaver wrapper classes.</strong></p>

<p>This ensures:</p>
<ul>
  <li>✅ Consistency across all backends</li>
  <li>✅ Predictable behavior (PoLS)</li>
  <li>✅ Single place for complexity</li>
  <li>✅ Simple backend implementations</li>
  <li>✅ Easy debugging</li>
</ul>

<h2 id="architecture-overview">Architecture Overview</h2>

<pre class="code ruby"><code class="ruby">User Code → TreeHaver::Parser → Backend → Raw Objects
            ↑ wraps/unwraps ↑    ↓ raw in/out ↓
User Code ← TreeHaver::Tree ←────┘
            TreeHaver::Node
</code></pre>

<h2 id="language-objects">Language Objects</h2>

<h3 id="wrapping-contract">Wrapping Contract</h3>

<p><strong>Input to <code>TreeHaver::Parser#language=</code>:</strong></p>
<ul>
  <li>User passes: <code>TreeHaver::Backends::*::Language</code> wrapper OR raw language object</li>
</ul>

<p><strong>TreeHaver::Parser unwraps:</strong></p>
<ul>
  <li>Calls <code>unwrap_language(lang)</code> helper method</li>
  <li>Passes unwrapped object to <code>backend.language=</code>
</li>
</ul>

<p><strong>Backend receives:</strong></p>
<ul>
  <li>MRI: <code>::TreeSitter::Language</code> (raw)</li>
  <li>Rust: <code>String</code> (language name)</li>
  <li>FFI: <code>TreeHaver::Backends::FFI::Language</code> (wrapper - needs <code>to_ptr</code>)</li>
  <li>Java: Java Language object (unwrapped from wrapper’s <code>impl</code>)</li>
  <li>Citrus: <code>Module</code> (grammar module)</li>
</ul>

<h3 id="unwrapping-logic">Unwrapping Logic</h3>

<p>Located in <code>TreeHaver::Parser#unwrap_language</code>:</p>

<pre class="code language-ruby"><code class="language-ruby">def unwrap_language(lang)
  # Check specific wrapper types using class.name string comparison
  # This approach is consistent, safe, and avoids autoload timing issues

  # Rust wrapper - extract language name string
  if lang.class.name == &quot;TreeHaver::Backends::Rust::Language&quot;
    return lang.name
  end

  # FFI wrapper - return as-is (needs to_ptr)
  if lang.class.name == &quot;TreeHaver::Backends::FFI::Language&quot;
    return lang
  end

  # MRI wrapper - has specific unwrapping methods (checked via respond_to?)
  return lang.to_language if lang.respond_to?(:to_language)
  return lang.inner_language if lang.respond_to?(:inner_language)

  # Java wrapper - extract impl
  if lang.class.name == &quot;TreeHaver::Backends::Java::Language&quot;
    return lang.impl
  end

  # Citrus wrapper - extract grammar module
  if lang.class.name == &quot;TreeHaver::Backends::Citrus::Language&quot;
    return lang.grammar_module
  end

  # Fallback for generic checks (backwards compatibility)
  return lang.impl if lang.respond_to?(:impl)
  return lang.grammar_module if lang.respond_to?(:grammar_module)

  lang  # Raw language, pass through
end
</code></pre>

<p><strong>Special Case: FFI Backend</strong></p>
<ul>
  <li>FFI is unique: it needs the wrapped <code>Language</code> object to call <code>to_ptr</code>
</li>
  <li>
<strong>CRITICAL:</strong> Must check <code>lang.is_a?(Backends::FFI::Language)</code> specifically</li>
  <li>
<strong>NOT</strong> just <code>respond_to?(:to_ptr)</code> - raw backend objects might also respond to this</li>
  <li>If we pass a non-FFI object that responds to <code>:to_ptr</code>, we get a segfault!</li>
  <li>FFI backend’s <code>language=</code> expects the wrapper, not unwrapped pointer</li>
</ul>

<p><strong>Why Class Name String Checks Are Critical:</strong></p>

<p>We use <code>lang.class.name == "TreeHaver::Backends::*::Language"</code> instead of <code>lang.is_a?(Backends::*::Language)</code> for several critical reasons:</p>

<ol>
  <li>
<strong>Autoload Safety:</strong>
    <ul>
      <li>Using <code>is_a?</code> can trigger autoload at the wrong time</li>
      <li>String comparison works even if the class isn’t fully loaded yet</li>
      <li>Avoids race conditions during backend initialization</li>
    </ul>
  </li>
  <li>
<strong>Cross-Backend Safety:</strong>
    <ul>
      <li>When switching backends, cached objects might be from different backends</li>
      <li>String comparison reliably distinguishes <code>FFI::Language</code> from <code>MRI::Language</code>
</li>
      <li>Prevents segfaults when wrong wrapper type is passed to native code</li>
    </ul>
  </li>
  <li>
<strong>Method Collision Prevention:</strong>
    <ul>
      <li>
<strong>Rust:</strong> Many objects have a <code>name</code> method</li>
      <li>
<strong>FFI:</strong> Raw backend objects might respond to <code>:to_ptr</code> (causing segfaults!)</li>
      <li>
<strong>Java:</strong> Multiple objects might have an <code>impl</code> accessor</li>
      <li>
<strong>Citrus:</strong> Various objects might have <code>grammar_module</code>
</li>
      <li>String checks ensure we only match the exact wrapper class</li>
    </ul>
  </li>
  <li>
<strong>Consistency:</strong>
    <ul>
      <li>All backend wrappers use the same detection pattern</li>
      <li>Easier to maintain and reason about</li>
      <li>Reduces cognitive load when debugging</li>
    </ul>
  </li>
</ol>

<p><strong>MRI Exception:</strong> MRI still uses <code>respond_to?</code> checks because <code>to_language</code> and <code>inner_language</code> are highly specific methods unlikely to collide with other objects.</p>

<h2 id="tree-objects">Tree Objects</h2>

<h3 id="wrapping-contract-1">Wrapping Contract</h3>

<p><strong>Parsing (initial):</strong></p>
<ol>
  <li>User calls <code>parser.parse(source)</code>
</li>
  <li>TreeHaver::Parser calls <code>backend.parse(source)</code>
</li>
  <li>Backend returns raw tree (TreeSitter::Tree, TreeStump::Tree, etc.)</li>
  <li>TreeHaver::Parser wraps: <code>Tree.new(raw_tree, source: source)</code>
</li>
  <li>User receives <code>TreeHaver::Tree</code>
</li>
</ol>

<p><strong>Incremental Parsing:</strong></p>
<ol>
  <li>User calls <code>parser.parse_string(old_tree, source)</code>
</li>
  <li>TreeHaver::Parser unwraps <code>old_tree.inner_tree</code>
</li>
  <li>TreeHaver::Parser calls <code>backend.parse_string(raw_old_tree, source)</code>
</li>
  <li>Backend receives raw tree, returns raw tree</li>
  <li>TreeHaver::Parser wraps: <code>Tree.new(raw_tree, source: source)</code>
</li>
  <li>User receives <code>TreeHaver::Tree</code>
</li>
</ol>

<h3 id="unwrapping-logic-1">Unwrapping Logic</h3>

<p>Located in <code>TreeHaver::Parser#parse_string</code>:</p>

<pre class="code language-ruby"><code class="language-ruby">old_impl = if old_tree.respond_to?(:inner_tree)
  old_tree.inner_tree
elsif old_tree.respond_to?(:instance_variable_get)
  # Fallback for compatibility with legacy wrappers
  old_tree.instance_variable_get(:@inner_tree) ||
    old_tree.instance_variable_get(:@impl) ||
    old_tree
else
  old_tree
end
</code></pre>

<p><strong>Backend Expectations:</strong></p>
<ul>
  <li>All backends receive raw backend tree objects (or nil)</li>
  <li>All backends return raw backend tree objects</li>
  <li>NO backend should do its own unwrapping (TreeHaver::Parser handles it)</li>
</ul>

<h2 id="node-objects">Node Objects</h2>

<h3 id="wrapping-contract-2">Wrapping Contract</h3>

<p><strong>Node Creation:</strong></p>
<ol>
  <li>Backend tree has <code>root_node</code> method returning raw backend node</li>
  <li>
<code>TreeHaver::Tree#root_node</code> wraps: <code>Node.new(raw_node, source: @source)</code>
</li>
  <li>
<code>TreeHaver::Node</code> methods (like <code>child</code>, <code>children</code>) wrap returned nodes</li>
  <li>User always works with <code>TreeHaver::Node</code> objects</li>
</ol>

<p><strong>No Unwrapping Needed:</strong></p>
<ul>
  <li>Nodes are never passed TO backends</li>
  <li>Nodes are only created FROM backend nodes</li>
  <li>One-way wrapping only</li>
</ul>

<h2 id="backend-compliance-checklist">Backend Compliance Checklist</h2>

<h3 id="language-handling">Language Handling</h3>
<ul class="task-list">
  <li class="task-list-item">
<input type="checkbox" class="task-list-item-checkbox" disabled><code>language=</code> accepts raw unwrapped object (not TreeHaver wrapper)</li>
  <li class="task-list-item">
<input type="checkbox" class="task-list-item-checkbox" disabled><code>language=</code> returns the object it received (for consistency)</li>
  <li class="task-list-item">
<input type="checkbox" class="task-list-item-checkbox" disabled>No unwrapping logic in backend (TreeHaver::Parser does it)</li>
</ul>

<h3 id="tree-handling-parse">Tree Handling (parse)</h3>
<ul class="task-list">
  <li class="task-list-item">
<input type="checkbox" class="task-list-item-checkbox" disabled><code>parse(source)</code> returns raw backend tree</li>
  <li class="task-list-item">
<input type="checkbox" class="task-list-item-checkbox" disabled>No wrapping in <code>parse</code> (TreeHaver::Parser wraps result)</li>
</ul>

<h3 id="tree-handling-parse_string">Tree Handling (parse_string)</h3>
<ul class="task-list">
  <li class="task-list-item">
<input type="checkbox" class="task-list-item-checkbox" disabled><code>parse_string(old_tree, source)</code> expects raw tree (already unwrapped)</li>
  <li class="task-list-item">
<input type="checkbox" class="task-list-item-checkbox" disabled><code>parse_string</code> returns raw backend tree</li>
  <li class="task-list-item">
<input type="checkbox" class="task-list-item-checkbox" disabled>No unwrapping in <code>parse_string</code> (TreeHaver::Parser does it)</li>
  <li class="task-list-item">
<input type="checkbox" class="task-list-item-checkbox" disabled>No wrapping in <code>parse_string</code> (TreeHaver::Parser wraps result)</li>
</ul>

<h3 id="documentation">Documentation</h3>
<ul class="task-list">
  <li class="task-list-item">
<input type="checkbox" class="task-list-item-checkbox" disabled>Document that backend receives unwrapped objects</li>
  <li class="task-list-item">
<input type="checkbox" class="task-list-item-checkbox" disabled>Document that backend returns unwrapped objects</li>
  <li class="task-list-item">
<input type="checkbox" class="task-list-item-checkbox" disabled>Note that TreeHaver::Parser handles all wrapping/unwrapping</li>
</ul>

<h2 id="current-backend-status">Current Backend Status</h2>

<table>
  <thead>
    <tr>
      <th>Backend</th>
      <th>Language</th>
      <th>parse</th>
      <th>parse_string</th>
      <th>Compliant</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>MRI</td>
      <td>✅</td>
      <td>✅</td>
      <td>✅</td>
      <td>✅</td>
    </tr>
    <tr>
      <td>Rust</td>
      <td>✅</td>
      <td>✅</td>
      <td>✅</td>
      <td>✅</td>
    </tr>
    <tr>
      <td>FFI</td>
      <td>✅*</td>
      <td>✅</td>
      <td>N/A</td>
      <td>✅</td>
    </tr>
    <tr>
      <td>Java</td>
      <td>✅</td>
      <td>✅</td>
      <td>✅</td>
      <td>✅</td>
    </tr>
    <tr>
      <td>Citrus</td>
      <td>✅</td>
      <td>✅</td>
      <td>✅</td>
      <td>✅</td>
    </tr>
  </tbody>
</table>

<p>* FFI is special case - receives wrapper (needs <code>to_ptr</code>)</p>

<h2 id="benefits-of-this-architecture">Benefits of This Architecture</h2>

<ol>
  <li>
<strong>Single Responsibility:</strong> Only TreeHaver::Parser knows about wrapping</li>
  <li>
<strong>Consistency:</strong> All backends follow the same pattern</li>
  <li>
<strong>Simplicity:</strong> Backends don’t need to handle wrapper types</li>
  <li>
<strong>Testability:</strong> Easy to mock at boundaries</li>
  <li>
<strong>Maintainability:</strong> Changes to wrapping logic are centralized</li>
  <li>
<strong>PoLS:</strong> Users never see backend-specific wrapper types</li>
  <li>
<strong>Performance:</strong> No double wrapping/unwrapping</li>
</ol>

<h2 id="anti-patterns-to-avoid">Anti-Patterns to Avoid</h2>

<p>❌ <strong>Don’t unwrap in backends:</strong></p>
<pre class="code language-ruby"><code class="language-ruby"># BAD - backend doing unwrapping
def language=(lang)
  inner = lang.respond_to?(:inner_language) ? lang.inner_language : lang
  @parser.language = inner
end
</code></pre>

<p>✅ <strong>Let TreeHaver::Parser unwrap:</strong></p>
<pre class="code language-ruby"><code class="language-ruby"># GOOD - backend expects unwrapped
def language=(lang)
  # lang is already unwrapped by TreeHaver::Parser
  @parser.language = lang
  lang
end
</code></pre>

<p>❌ <strong>Don’t wrap in backends:</strong></p>
<pre class="code language-ruby"><code class="language-ruby"># BAD - backend doing wrapping
def parse(source)
  raw_tree = @parser.parse(source)
  TreeHaver::Tree.new(raw_tree, source: source)  # Wrong!
end
</code></pre>

<p>✅ <strong>Return raw objects:</strong></p>
<pre class="code language-ruby"><code class="language-ruby"># GOOD - return raw, TreeHaver::Parser wraps
def parse(source)
  @parser.parse(source)  # Return raw tree
end
</code></pre>

<h2 id="testing-strategy">Testing Strategy</h2>

<h3 id="unit-tests-backend">Unit Tests (Backend)</h3>
<ul>
  <li>Pass raw objects to backend methods</li>
  <li>Verify backend returns raw objects</li>
  <li>No TreeHaver wrapper types in backend tests</li>
</ul>

<h3 id="integration-tests-treehaverparser">Integration Tests (TreeHaver::Parser)</h3>
<ul>
  <li>Pass wrapped objects to TreeHaver::Parser</li>
  <li>Verify TreeHaver::Parser unwraps before calling backend</li>
  <li>Verify TreeHaver::Parser wraps backend results</li>
  <li>Verify users receive TreeHaver wrapper types</li>
</ul>

<h3 id="contract-tests">Contract Tests</h3>
<ul>
  <li>Verify all backends follow the same contract</li>
  <li>Test with different wrapper types</li>
  <li>Test with raw objects (should pass through)</li>
  <li>Test nil handling</li>
</ul>
</div></div>

      <div id="footer">
  Generated on Tue Dec 30 03:22:58 2025 by
  <a href="https://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.9.38 (ruby-4.0.0).
</div>

    </div>
  </body>
</html>