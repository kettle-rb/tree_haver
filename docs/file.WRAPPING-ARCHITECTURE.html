<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  File: WRAPPING-ARCHITECTURE
  
    &mdash; Documentation by YARD 0.9.38
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" />

  <link rel="stylesheet" href="css/common.css" type="text/css" />

<script type="text/javascript">
  pathId = "WRAPPING-ARCHITECTURE";
  relpath = '';
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="file_list.html?1"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  
    <a href="_index.html">Index</a> &raquo; 
    <span class="title">File: WRAPPING-ARCHITECTURE</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <div id="content"><div id='filecontents'><h1 id="treehaver-wrappingunwrapping-architecture">TreeHaver Wrapping/Unwrapping Architecture</h1>

<h2 id="principle-of-least-surprise-pols">Principle of Least Surprise (PoLS)</h2>

<p>TreeHaver follows a <strong>single responsibility</strong> pattern for object wrapping:</p>

<ul>
  <li>
<strong>TreeHaver::Parser</strong> (top level) handles ALL wrapping and unwrapping</li>
  <li>
<strong>Backends</strong> work exclusively with raw backend objects</li>
  <li>
<strong>User-facing API</strong> uses only TreeHaver wrapper classes</li>
</ul>

<p>This ensures:</p>
<ul>
  <li>Consistency across all backends</li>
  <li>Predictable behavior (PoLS)</li>
  <li>Single place for complexity</li>
  <li>Simple backend implementations</li>
  <li>Easy debugging</li>
</ul>

<h2 id="architecture-overview">Architecture Overview</h2>

<pre class="code ruby"><code class="ruby">User Code → TreeHaver::Parser → Backend → Raw Objects
            ↑ wraps/unwraps ↑    ↓ raw in/out ↓
User Code ← TreeHaver::Tree ←────┘
            TreeHaver::Node
</code></pre>

<h2 id="inheritance-hierarchy">Inheritance Hierarchy</h2>

<h3 id="base-classes">Base Classes</h3>

<p>Located in <code>lib/tree_haver/base/</code>:</p>

<ul>
  <li>
<code>TreeHaver::Base::Parser</code> - Base class for backend Parser implementations</li>
  <li>
<code>TreeHaver::Base::Tree</code> - Base class for backend Tree implementations</li>
  <li>
<code>TreeHaver::Base::Node</code> - Base class for backend Node implementations (provides Position API)</li>
</ul>

<h3 id="top-level-wrappers">Top-Level Wrappers</h3>

<p>Located in <code>lib/tree_haver/</code>:</p>

<ul>
  <li>
<code>TreeHaver::Parser</code> - Inherits from <code>Base::Parser</code>, handles wrapping/unwrapping</li>
  <li>
<code>TreeHaver::Tree</code> - Inherits from <code>Base::Tree</code>, wraps tree-sitter backend trees</li>
  <li>
<code>TreeHaver::Node</code> - Inherits from <code>Base::Node</code>, wraps tree-sitter backend nodes</li>
</ul>

<h3 id="backend-specific-classes">Backend-Specific Classes</h3>

<p>Pure-Ruby backends define their own complete implementations:</p>

<ul>
  <li>
<code>Backends::Citrus::{Parser,Tree,Node}</code> - Inherits from <code>Base::*</code>
</li>
  <li>
<code>Backends::Parslet::{Parser,Tree,Node}</code> - Inherits from <code>Base::*</code>
</li>
  <li>
<code>Backends::Prism::{Parser,Tree,Node}</code> - Inherits from <code>Base::*</code>
</li>
  <li>
<code>Backends::Psych::{Parser,Tree,Node}</code> - Inherits from <code>Base::*</code>
</li>
</ul>

<p>Tree-sitter backends (MRI, Rust, FFI, Java) do NOT define their own Tree/Node classes. They return raw backend objects that <code>TreeHaver::Tree</code> and <code>TreeHaver::Node</code> wrap.</p>

<h2 id="language-objects">Language Objects</h2>

<h3 id="wrapping-contract">Wrapping Contract</h3>

<p><strong>Input to <code>TreeHaver::Parser#language=</code>:</strong></p>
<ul>
  <li>User passes: <code>TreeHaver::Backends::*::Language</code> wrapper</li>
</ul>

<p><strong>TreeHaver::Parser unwraps:</strong></p>
<ul>
  <li>Calls <code>unwrap_language(lang)</code> helper method</li>
  <li>Verifies backend compatibility via <code>lang.backend</code>
</li>
  <li>Attempts reload if backend mismatch detected</li>
</ul>

<p><strong>Backend receives (after unwrapping):</strong></p>

<table>
  <thead>
    <tr>
      <th>Backend</th>
      <th>Receives</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>MRI</td>
      <td>
<code>::TreeSitter::Language</code> (via <code>to_language</code> or <code>inner_language</code>)</td>
    </tr>
    <tr>
      <td>Rust</td>
      <td>
<code>String</code> (language name via <code>name</code>)</td>
    </tr>
    <tr>
      <td>FFI</td>
      <td>
<code>TreeHaver::Backends::FFI::Language</code> wrapper (needs <code>to_ptr</code>)</td>
    </tr>
    <tr>
      <td>Java</td>
      <td>Java Language object (via <code>impl</code>)</td>
    </tr>
    <tr>
      <td>Citrus</td>
      <td>
<code>TreeHaver::Backends::Citrus::Language</code> wrapper</td>
    </tr>
    <tr>
      <td>Parslet</td>
      <td>
<code>TreeHaver::Backends::Parslet::Language</code> wrapper</td>
    </tr>
    <tr>
      <td>Prism</td>
      <td>
<code>TreeHaver::Backends::Prism::Language</code> wrapper</td>
    </tr>
    <tr>
      <td>Psych</td>
      <td>
<code>TreeHaver::Backends::Psych::Language</code> wrapper</td>
    </tr>
  </tbody>
</table>

<h3 id="unwrapping-logic">Unwrapping Logic</h3>

<p>Located in <code>TreeHaver::Parser#unwrap_language</code>:</p>

<pre class="code language-ruby"><code class="language-ruby">def unwrap_language(lang)
  # Verify backend compatibility
  if lang.respond_to?(:backend)
    current_backend = backend
    if lang.backend != current_backend &amp;&amp; current_backend != :auto
      # Backend mismatch - attempt reload
      reloaded = try_reload_language_for_backend(lang, current_backend)
      lang = reloaded if reloaded
    end
  end

  # Unwrap based on backend type
  case lang.backend
  when :mri
    lang.to_language || lang.inner_language
  when :rust
    lang.name
  when :ffi
    lang  # FFI needs wrapper for to_ptr
  when :java
    lang.impl
  when :citrus, :parslet, :prism, :psych
    lang  # These backends accept the Language wrapper
  else
    # Unknown backend - try generic unwrapping
    lang
  end
end
</code></pre>

<p><strong>Special Case: FFI Backend</strong></p>
<ul>
  <li>FFI is unique: it needs the wrapped <code>Language</code> object to call <code>to_ptr</code>
</li>
  <li>The FFI backend’s <code>language=</code> expects the wrapper, not an unwrapped pointer</li>
</ul>

<p><strong>Backend Attribute Requirement</strong></p>
<ul>
  <li>All TreeHaver Language wrappers have a <code>backend</code> attribute</li>
  <li>This enables backend compatibility checking</li>
  <li>Passing a raw backend object (without <code>backend</code> attribute) raises an error</li>
</ul>

<h2 id="tree-objects">Tree Objects</h2>

<h3 id="wrapping-contract-1">Wrapping Contract</h3>

<p><strong>Parsing (initial):</strong></p>
<ol>
  <li>User calls <code>parser.parse(source)</code>
</li>
  <li>TreeHaver::Parser calls <code>backend.parse(source)</code>
</li>
  <li>Backend returns raw tree (TreeSitter::Tree, TreeStump::Tree, etc.)</li>
  <li>TreeHaver::Parser wraps: <code>Tree.new(raw_tree, source: source)</code>
</li>
  <li>User receives <code>TreeHaver::Tree</code>
</li>
</ol>

<p><strong>Incremental Parsing:</strong></p>
<ol>
  <li>User calls <code>parser.parse_string(old_tree, source)</code>
</li>
  <li>TreeHaver::Parser unwraps <code>old_tree.inner_tree</code>
</li>
  <li>TreeHaver::Parser calls <code>backend.parse_string(raw_old_tree, source)</code>
</li>
  <li>Backend receives raw tree, returns raw tree</li>
  <li>TreeHaver::Parser wraps: <code>Tree.new(raw_tree, source: source)</code>
</li>
  <li>User receives <code>TreeHaver::Tree</code>
</li>
</ol>

<h3 id="unwrapping-logic-1">Unwrapping Logic</h3>

<p>Located in <code>TreeHaver::Parser#parse_string</code>:</p>

<pre class="code language-ruby"><code class="language-ruby">old_impl = if old_tree.respond_to?(:inner_tree)
  old_tree.inner_tree
elsif old_tree.respond_to?(:instance_variable_get)
  # Fallback for compatibility
  old_tree.instance_variable_get(:@inner_tree) ||
    old_tree.instance_variable_get(:@impl) ||
    old_tree
else
  old_tree
end
</code></pre>

<p><strong>Backend Expectations:</strong></p>
<ul>
  <li>All backends receive raw backend tree objects (or nil)</li>
  <li>All backends return raw backend tree objects</li>
  <li>NO backend should do its own unwrapping (TreeHaver::Parser handles it)</li>
</ul>

<h2 id="node-objects">Node Objects</h2>

<h3 id="wrapping-contract-2">Wrapping Contract</h3>

<p><strong>Node Creation:</strong></p>
<ol>
  <li>Backend tree has <code>root_node</code> method returning raw backend node</li>
  <li>
<code>TreeHaver::Tree#root_node</code> wraps: <code>Node.new(raw_node, source: @source)</code>
</li>
  <li>
<code>TreeHaver::Node</code> methods (like <code>child</code>, <code>children</code>) wrap returned nodes</li>
  <li>User always works with <code>TreeHaver::Node</code> objects</li>
</ol>

<p><strong>No Unwrapping Needed:</strong></p>
<ul>
  <li>Nodes are never passed TO backends</li>
  <li>Nodes are only created FROM backend nodes</li>
  <li>One-way wrapping only</li>
</ul>

<h2 id="backend-compliance-checklist">Backend Compliance Checklist</h2>

<h3 id="language-handling">Language Handling</h3>
<ul>
  <li>
<code>language=</code> accepts raw unwrapped object (or wrapper for Citrus/Parslet/Prism/Psych/FFI)</li>
  <li>
<code>language=</code> returns the object it received (for consistency)</li>
  <li>No unwrapping logic in backend (TreeHaver::Parser does it)</li>
</ul>

<h3 id="tree-handling-parse">Tree Handling (parse)</h3>
<ul>
  <li>
<code>parse(source)</code> returns raw backend tree</li>
  <li>No wrapping in <code>parse</code> (TreeHaver::Parser wraps result)</li>
</ul>

<h3 id="tree-handling-parse_string">Tree Handling (parse_string)</h3>
<ul>
  <li>
<code>parse_string(old_tree, source)</code> expects raw tree (already unwrapped)</li>
  <li>
<code>parse_string</code> returns raw backend tree</li>
  <li>No unwrapping in <code>parse_string</code> (TreeHaver::Parser does it)</li>
  <li>No wrapping in <code>parse_string</code> (TreeHaver::Parser wraps result)</li>
</ul>

<h2 id="current-backend-status">Current Backend Status</h2>

<table>
  <thead>
    <tr>
      <th>Backend</th>
      <th>Language</th>
      <th>parse</th>
      <th>parse_string</th>
      <th>Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>MRI</td>
      <td>✓</td>
      <td>✓</td>
      <td>✓</td>
      <td>C extension, MRI only</td>
    </tr>
    <tr>
      <td>Rust</td>
      <td>✓</td>
      <td>✓</td>
      <td>✓</td>
      <td>Rust via magnus, MRI only</td>
    </tr>
    <tr>
      <td>FFI</td>
      <td>✓*</td>
      <td>✓</td>
      <td>N/A</td>
      <td>*Receives wrapper (needs <code>to_ptr</code>)</td>
    </tr>
    <tr>
      <td>Java</td>
      <td>✓</td>
      <td>✓</td>
      <td>✓</td>
      <td>JRuby only</td>
    </tr>
    <tr>
      <td>Citrus</td>
      <td>✓</td>
      <td>✓</td>
      <td>✓</td>
      <td>Pure Ruby PEG</td>
    </tr>
    <tr>
      <td>Parslet</td>
      <td>✓</td>
      <td>✓</td>
      <td>✓</td>
      <td>Pure Ruby PEG</td>
    </tr>
    <tr>
      <td>Prism</td>
      <td>✓</td>
      <td>✓</td>
      <td>✓</td>
      <td>Ruby parser (stdlib)</td>
    </tr>
    <tr>
      <td>Psych</td>
      <td>✓</td>
      <td>✓</td>
      <td>✓</td>
      <td>YAML parser (stdlib)</td>
    </tr>
  </tbody>
</table>

<h2 id="benefits-of-this-architecture">Benefits of This Architecture</h2>

<ol>
  <li>
<strong>Single Responsibility</strong> - Only TreeHaver::Parser knows about wrapping</li>
  <li>
<strong>Consistency</strong> - All backends follow the same pattern</li>
  <li>
<strong>Simplicity</strong> - Backends don’t need to handle wrapper types</li>
  <li>
<strong>Testability</strong> - Easy to mock at boundaries</li>
  <li>
<strong>Maintainability</strong> - Changes to wrapping logic are centralized</li>
  <li>
<strong>PoLS</strong> - Users never see backend-specific wrapper types</li>
  <li>
<strong>Performance</strong> - No double wrapping/unwrapping</li>
</ol>

<h2 id="anti-patterns-to-avoid">Anti-Patterns to Avoid</h2>

<p><strong>Don’t unwrap in backends:</strong></p>
<pre class="code language-ruby"><code class="language-ruby"># BAD - backend doing unwrapping
def language=(lang)
  inner = lang.respond_to?(:inner_language) ? lang.inner_language : lang
  @parser.language = inner
end
</code></pre>

<p><strong>Let TreeHaver::Parser unwrap:</strong></p>
<pre class="code language-ruby"><code class="language-ruby"># GOOD - backend expects unwrapped (or wrapper for some backends)
def language=(lang)
  # lang is already processed by TreeHaver::Parser
  @parser.language = lang
  lang
end
</code></pre>

<p><strong>Don’t wrap in backends:</strong></p>
<pre class="code language-ruby"><code class="language-ruby"># BAD - backend doing wrapping
def parse(source)
  raw_tree = @parser.parse(source)
  TreeHaver::Tree.new(raw_tree, source: source)  # Wrong!
end
</code></pre>

<p><strong>Return raw objects:</strong></p>
<pre class="code language-ruby"><code class="language-ruby"># GOOD - return raw, TreeHaver::Parser wraps
def parse(source)
  @parser.parse(source)  # Return raw tree
end
</code></pre>

<h2 id="testing-strategy">Testing Strategy</h2>

<h3 id="unit-tests-backend">Unit Tests (Backend)</h3>
<ul>
  <li>Pass raw objects to backend methods</li>
  <li>Verify backend returns raw objects</li>
  <li>No TreeHaver wrapper types in backend tests</li>
</ul>

<h3 id="integration-tests-treehaverparser">Integration Tests (TreeHaver::Parser)</h3>
<ul>
  <li>Pass wrapped objects to TreeHaver::Parser</li>
  <li>Verify TreeHaver::Parser unwraps before calling backend</li>
  <li>Verify TreeHaver::Parser wraps backend results</li>
  <li>Verify users receive TreeHaver wrapper types</li>
</ul>

<h3 id="contract-tests">Contract Tests</h3>
<ul>
  <li>Verify all backends follow the same contract</li>
  <li>Test with different wrapper types</li>
  <li>Test with raw objects (should pass through)</li>
  <li>Test nil handling</li>
</ul>
</div></div>

      <div id="footer">
  Generated on Tue Jan 20 13:17:43 2026 by
  <a href="https://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.9.38 (ruby-4.0.1).
</div>

    </div>
  </body>
</html>